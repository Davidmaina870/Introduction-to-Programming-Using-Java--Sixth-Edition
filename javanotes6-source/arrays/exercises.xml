<?xml version="1.0" encoding="UTF-8"?>


<exercises>

<exercise>
<exercise-question><p>An example in <localref href="arrays.2.4"/>
tried to answer the question, How many random people
do you have to select before you find a duplicate birthday? The source code for
that program can be found in the file
<sourceref href="BirthdayProblemDemo.java"/>. Here are
some related questions:</p>
<ul>
<li>How many random people do you have to select before you find <b>three</b>
people who share the same birthday? (That is, all three people were born on the
same day in the same month, but not necessarily in the same year.)</li>
<li>Suppose you choose 365 people at random. How many different birthdays will
they have? (The number could theoretically be anywhere from 1 to 365).</li>
<li>How many different people do you have to check before you've found at least
one person with a birthday on each of the 365 days of the year?</li>
</ul>
<p>Write <b>three</b> programs to answer these questions. Each of your programs should simulate
choosing people at random and checking their birthdays. (In each case, ignore
the possibility of leap years.)</p>
</exercise-question>
<exercise-discuss><p>The original program has a subroutine, <code>birthdayProblem()</code>, that does
the simulation once. The <code>main()</code> routine calls this subroutine over and
over, as long as the user wants to continue. The three programs can all use the
same <code>main()</code> routine, along with a modified <code>birthdayProblem()</code>
routine. The changes from the original program are not huge, but you need a
clear understanding of arrays in order to get them right. Let's look at each of
the problems in turn. I'll just look at the <code>birthdayProblem()</code>
subroutines. The complete programs are given below.</p>

<break/>

<p>The first question asks how many people you have to choose at random before
finding three who share the same birthday. This is similar to the original
program, but instead of just checking whether or not a given birthday has
already been found, we need to keep track of how many people have been found
with each birthday. Where the original program used an array of
<code>booleans</code>, here we need an array of <code>ints</code>. We still want to
count the number of people we check and output that count at the end. An
algorithm for the simulation is:</p>

<pre>Let count = 0
Repeat:
   Select a birthday at random
   Add one to count
   If this is the third time that birthday has occurred:
       break out of the loop
   Add one to the number of times that birthday has been found
Output the count</pre>

<p>To do the counting, we need an array "<code>int[] numFound</code>", where
<code>numFound[i]</code> will be the number of times the <code>i</code>-th day of the
year has occurred as a birthday. Since <code>numFound[i]</code> can be used in any
way that any <ptype>int</ptype> variable can be used, we can add one to the number
stored in <code>numFound[i]</code> by saying "<code>numFound[i]++</code>". When we
create the array with the command "<code>numFound&nbsp;=&nbsp;new&nbsp;int[365]</code>", all the
elements of the array are automatically initialized to zero. This is the
initial value that we want. (This is an important thing to remember! In some
programming languages, arrays are not automatically filled with zeros, so it
would be necessary to use a <code>for</code> loop to store a zero into each place
in the array. Even in Java, if you wrote this program differently and reused
the same array rather than creating a new one for each simulation, you would
have to remember to set each element of the array to zero at the beginning of
the simulation.)</p>

<p>Given all this, we can translate the algorithm into Java as follows:</p>

<pre><newcode>int[] numFound;  // numFound[i] will be the number of people
                 // who have been found who have a birthday
                 // on the i-th day of the year</newcode>

int count;       // The number of people who have been checked.

<newcode>numFound = new int[365];  // Initially, all entries are 0.</newcode>

count = 0;

while (true) {
       // Select a birthday at random, from 0 to 364.
       // If the same birthday was already seen twice
       // before, then quit.  Otherwise, add one to
       // the corresponding entry in the numFound array
       // to record that a person with that birthday
       // has been found.
   int birthday;  // The selected birthday.
   birthday = (int)(Math.random()*365);
   count++;
   <newcode>if ( numFound[birthday] == 2 )
       break;  // It's the third time we've found this birthday.
   numFound[birthday]++;</newcode>
}

TextIO.putln("It took " + count + 
        " tries to find three people with the same birthday.");</pre>

<np>The lines shown in &newcodestyle; are the ones that differ significantly from the
original program. This becomes the body of the <code>birthdayProblem()</code>
subroutine in the first program.</np>


<break/>

<p>For the second program, we know exactly how many people we want to check:
365. This calls for using a for loop. The information we need for each birthday
is whether or not that birthday has occurred. For that, we can use an array of
<ptype>booleans</ptype>. The value stored in position <code>i</code> of the array is
<code>true</code> if the <code>i</code>-th day of the year has occurred as a birthday
and is <code>false</code> if not. After checking 365 people, we have to go through
the array and count the number of entries in the array that are <code>true</code>.
This is the number of different birthdays that have been found. The algorithm
can be expressed as:</p>

<pre>Let used = new boolean[365]
Repeat 365 times:
   Select a birthday at random
   Store true into the corresponding location in the array, used
Let count = 0
for day = 0 to 364:
   If used[day] is true:
      Add 1 to count
Output the value of count</pre>

<np>This translates easily into Java code:</np>

<pre>boolean used[];  // used[i] will be true if a person is found
                 // whose birthday is the i-th day of the year.

used = new boolean[365];  // <b>Initially, all entries are false!</b>

for (int i = 0; i &lt; 365; i++) {
      // Select a random birthday and record it.
   int birthday;  // The selected birthday.
   birthday = (int)(Math.random()*365);
   used[birthday] = true;
}

int count = 0;

for (int day = 0; day &lt; 365; day++) {
       // If this day occurred as a birthday, count it.
   if (used[day] == true)
      count++;
}

TextIO.putln("Among 365 people, there were " + count
                                + " different birthdays.");</pre>

<p>It might be worth noting that the test "<code>if&nbsp;(used[day]&nbsp;==&nbsp;true)</code>" can
be written more simply as "<code>if&nbsp;(used[day])</code>". Also, the three lines in
the first <code>for</code> loop could be reduced to the single command
"<code>used[(int)(Math.random()*365)]&nbsp;=&nbsp;true;</code>". Of course, this one-line
version is harder to understand.</p>

<break/>

<p>The third program is just a little bit trickier. We have to continue
selecting people at random until we have found 365 different birthdays. We can
use a counter to keep track of how many different birthdays we have found. We
have to continue until this counter reaches 365. We need a second counter to
keep track of how many different people we have checked. It's the second
counter whose value we want to output at the end. Now, we have to be able to
recognize whether a birthday we've just found is new, or whether we've
encountered it previously. For this, we can again use an array of
<ptype>booleans</ptype>. An algorithm for the simulation is:</p>

<pre>Let used = new boolean[365]
Let count = 0   // The number of people checked
Let birthdaysFound = 0   // The number of different birthdays found
while birthdaysFound &lt; 365:
   Add one to count
   Select a birthday at random
   if used[birthday] is false:
       Add one to birthdaysFound  // since this is a new birthday
   Let used[birthday] = true   // so we don't count it again
Output the value of count</pre>

<np>In Java, this algorithm becomes:</np>

<pre>boolean[] used;  // For recording the possible birthdays
                 //   that have been seen so far.
int count;       // The number of people who have been checked.
int birthdaysFound;   // The number of different birthdays that
                      // have been found.

used = new boolean[365];  // Initially, all entries are false.
count = 0;
birthdaysFound = 0;

while (birthdaysFound &lt; 365) {
       // Select a birthday at random, from 0 to 364.
       // If the birthday has not already been used,
       // add 1 to birthdaysFound.
   int birthday;  // The selected birthday.
   birthday = (int)(Math.random()*365);
   count++;
   if ( used[birthday] == false )
      birthdaysFound++;
   used[birthday] = true;
}

TextIO.putln( count + " people were checked." );</pre>
</exercise-discuss>
<exercise-code>
<p><b>Finding three people with the same birthday:</b>
</p>

<pre>/**
 *  How many random people do you have to select before you find
 *  THREE with the same birthday (that is, three people who were born 
 *  on the same day of the same month, but not necessarily in the 
 *  same year).  This program simulates the process.  (It ignores the
 *  possibility of people born on leap day.)
 */

public class BirthdayProblem2 {

   public static void main(String[] args) {
   
       TextIO.putln("This program simulates taking people at random");
       TextIO.putln("until three have been found who were born on the");
       TextIO.putln("same day of the year.\n");
       
       do {
          birthdayProblem();
          TextIO.put("\nAgain? ");
       } while ( TextIO.getlnBoolean() );
       
       TextIO.putln("\n\nOK.  Goodbye.");
       
   } // end main()
   

   /**
    * Simulate choosing people at random and checking the
    * day of the year they were born on.  If the person is
    * the third who was born on that day of the year, stop,
    * and output the number of people who were checked.
    */
   static void birthdayProblem() {

      int[] numFound;  // numFound[i] will be the number of people
                       // who have been found who have a birthday
                       // on the i-th day of the year
      
      int count;       // The number of people who have been checked.

      numFound = new int[365];  // Initially, all entries are 0.
      
      count = 0;

      while (true) {
             // Select a birthday at random, from 0 to 364.
             // If the same birthday was already seen twice
             // before, then quit.  Otherwise, add one to
             // the corresponding entry in the numFound array 
             // to record that a person with that birthday
             // has been found.
         int birthday;  // The selected birthday.
         birthday = (int)(Math.random()*365);
         count++;
         if ( numFound[birthday] == 2 )
            break;
         numFound[birthday]++;
      }

      TextIO.putln("It took " + count + 
               " tries to find three people with the same birthday.");

   } // end birthdayProblem()
 
   
} // end class BirthdayProblem2
   
</pre>

<p><b>How many different birthdays do 365 people have?</b>
</p>

<pre>/**
 * This program simulates selecting 365 people at random and finding
 * how many different birthdays they have among them.
 */

public class BirthdayProblem3 {

   public static void main(String[] args) {
   
       TextIO.putln("This program simulates taking 365 people at random");
       TextIO.putln("and finding out how many different birthdays they");
       TextIO.putln("have among them.\n");
       
       do {
          birthdayProblem();
          TextIO.put("\nAgain? ");
       } while ( TextIO.getlnBoolean() );
       
       TextIO.putln("\n\nOK.  Goodbye.");
       
   } // end main()
   
   
   /**
    * Simulate choosing people at random and checking the
    * day of the year they were born on.  The number of
    * different days found among 365 people is counted
    * and output.
    */
   static void birthdayProblem() {
   
      boolean used[];  // used[i] will be true if a person is found
                       // whose birthday is on the i-th day of the year.
      
      used = new boolean[365];  // Initially, all entries are false.
      
      /* Choose 365 days at random, and mark each day by
         setting the corresponding entry in the array, used,
         to true.  (If the value is already true, it doesn't 
         matter.  We are only interested in whether or not
         the birthday occurs, not how many times it occurs.)
      */
      
      for (int i = 0; i &lt; 365; i++) {
         int birthday;  // The selected birthday.
         birthday = (int)(Math.random()*365);
         used[birthday] = true;
      }
      
      /* Now, count how many entries in the used array are true.
         This is how many different birthdays were found.
      */
      
      int count = 0;
      
      for (int day = 0; day &lt; 365; day++) {
             // If this day occurred as a birthday, count it.
         if (used[day] == true)
            count++;
      }

      TextIO.putln("Among 365 people, there were " + count
                                      + " different birthdays.");

   } // end birthdayProblem()
 
   
} // end class BirthdayProblem3


</pre>

<p><b>Finding 365 different birthdays:</b>
</p>

<pre>/**
 * How many random people do you have to select before you 
 *  have found someone with every possible birthday (ignoring
 *  leap years)?  This program simulates the process.
 */
 
public class BirthdayProblem4 {
 
    public static void main(String[] args) {
    
        TextIO.putln("This program simulates taking people at random");
        TextIO.putln("until someone has been found with a birthday");
        TextIO.putln("on every day of the year.\n");
        
        do {
           birthdayProblem();
           TextIO.put("\nAgain? ");
        } while ( TextIO.getlnBoolean() );
        
        TextIO.putln("\n\nOK.  Goodbye.");
        
    } // end main()
    

    /*       
     * Simulate choosing people at random and checking the
     * day of the year they were born on.  People are chosen
     * until all 365 possible birthdays (ignoring leap years)
     * have been found.  Then the number of people surveyed
     * is output.
     */
    static void birthdayProblem() {
 
       boolean[] used;  // For recording the possible birthdays
                        //   that have been seen so far.  A value
                        //   of true in used[i] means that a person
                        //   whose birthday is the i-th day of the
                        //   year has been found.
 
       int count;       // The number of people who have been checked.
       
       int birthdaysFound;   // The number of different birthdays that
                             // have been found.
 
       used = new boolean[365];  // Initially, all entries are false.
       
       count = 0;
       
       birthdaysFound = 0;
 
       while (birthdaysFound &lt; 365) {
              // Select a birthday at random, from 0 to 364.
              // If the birthday has not already been used,
              // add 1 to birthdaysFound.
          int birthday;  // The selected birthday.
          birthday = (int)(Math.random()*365);
          count++;
          if ( used[birthday] == false )
             birthdaysFound++;
          used[birthday] = true;
       }
 
       TextIO.putln( count + " people were checked." );
 
    } // end birthdayProblem()
  
    
} // end class BirthdayProblem4
</pre>
</exercise-code>
</exercise>   

   
   
<exercise>
<exercise-question><p>Write a program that will
read a sequence of positive real numbers entered by the user and will print the
same numbers in sorted order from smallest to largest. The user will input a
zero to mark the end of the input. Assume that at most 100 positive numbers
will be entered.</p>
</exercise-question>
<exercise-discuss><p>The sample program 
<sourceref href="ReverseWithDynamicArray.java"/> from
<localref href="arrays.3.2"/> reads in up to 100 positive integers from the
user and outputs them in the reverse of the order in which the user entered
them. This is similar to what we have to do for this exercise, except that the
numbers we have to read are real numbers (of type <ptype>double</ptype>) and they
have to be output in sorted order.</p>

<p>There are two basic approaches to this problem. The first is to store all
the numbers in an array in the order in which they are input. After all the
numbers have been input, the array can be sorted, and then the contents of the
array can be output. The second approach is to always keep the array in sorted
order as numbers are added to it. When a new number is input, that number must
be inserted into its correct location in the array, in order to keep the array
sorted. After all the numbers have been input, the contents of the array are
ready to be printed.</p>

<p>Two solutions to the exercise, based on these two approaches, are shown
below. They use techniques for sorting and inserting that were covered in
<localref href="arrays.4"/>. In my first program, I've chosen to use
Selection Sort to sort the array. Insertion Sort would work just as well. The
Selection Sort subroutine is taken from <localref href="arrays.4"/> with two changes: It sorts
an array of <ptype>double</ptype> values instead of an array of <code>ints</code>, and it
has been modified to work with a "partially full" array. In order to make the
subroutine work with a partially full array, it is necessary to add a parameter
that tells the subroutine how many entries in the array are in use. The
modified Selection Sort routine is as follows, with changes from the original
version shown in &newcodestyle;</p>

<pre>static void selectionSort(<newcode>double</newcode>[] A, <newword>int count</newword>) {
      // Sort the numbers in A[0], A[1], ..., A[count-1] into
      // increasing order using Selection Sort.
   for ( int lastPlace = <newcode>count</newcode> - 1; lastPlace &gt; 0; lastPlace-- ) {
      int maxLoc = 0;
      for (int j = 1; j &lt;= lastPlace; j++) {
         if (A[j] &gt; A[maxLoc]) {
            maxLoc = j;
         }
      }
      <newcode>double</newcode> temp = A[maxLoc];
      A[maxLoc] = A[lastPlace];
      A[lastPlace] = temp;
   }
} // end selectionSort</pre>

<np>In the first version of the program, this subroutine is called just after
all the numbers have been input from the user.</np>

<p>The second version of the program is straightforward. It uses the
<code>insert()</code> subroutine from <localref href="arrays.4"/>, modified to work with an array
of <code>doubles</code> instead of an array of <code>ints</code>.</p>
</exercise-discuss>
<exercise-code><p><b>First solution, with Selection Sort:</b>
</p>

<pre>
    /**
     * This program reads up to 100 positive integers from the user and 
     * prints them in sorted order.  Input ends when the user enters a 
     * non-positive integer.  The numbers are read and stored in an array.
     * That array is sorted using selection sort, and then the array is
     * printed.
     */
    
    public class SortInputNumbers {
    
       public static void main(String[] args) {
      
          double[] numbers;  // An array for storing the input values.
          int numCt;         // The number of numbers saved in the array.
          double num;        // One of the numbers input by the user.
        
          numbers = new double[100];   // Space for 100 numbers.
          numCt = 0;                   // No numbers have been saved yet.
        
          TextIO.putln("Enter up to 100 positive numbers; Enter 0 to end");
        
          while (true) {   // Get the numbers and put them in the array.
             TextIO.put("? ");
             num = TextIO.getlnDouble();
             if (num &lt;= 0)
                break;
             numbers[numCt] = num;
             numCt++;
          }
          
          selectionSort(numbers, numCt);  // Sort the numbers.
        
          TextIO.putln("\nYour numbers in sorted order are:\n");
        
          for (int i = 0; i &lt; numCt; i++) {
              TextIO.putln( numbers[i] );
          }
        
       } // end main();
       
       /**
        * Sort the numbers in A[0], A[1], ..., A[count-1] into
        * increasing order using Selection Sort.
        */
       static void selectionSort(double[] A, int count) {
          for ( int lastPlace = count - 1; lastPlace &gt; 0; lastPlace-- ) {
             int maxLoc = 0;
             for (int j = 1; j &lt;= lastPlace; j++) {
                if (A[j] &gt; A[maxLoc]) {
                   maxLoc = j;
                }
             }
             double temp = A[maxLoc];
             A[maxLoc] = A[lastPlace];
             A[lastPlace] = temp;
          }
       } // end selectionSort
      
    }  // end class SortInputNumbers
</pre>

<p><b>Second solution, with Insert:</b>
</p>

<pre>/**
 * This program reads up to 100 positive integers from the user and 
 * prints them in sorted order.  Input ends when the user enters a
 * non-positive integer.  The numbers are read and inserted into
 * an array.  The array is maintained at all times in sorted order.
 */

public class SortInputNumbers {

   public static void main(String[] args) {
  
      double[] numbers;  // An array for storing the input values.
      int numCt;         // The number of numbers saved in the array.
      double num;        // One of the numbers input by the user.
    
      numbers = new double[100];   // Space for 100 numbers.
      numCt = 0;                   // No numbers have been saved yet.
    
      TextIO.putln("Enter up to 100 positive numbers; Enter 0 to end");
    
      while (true) {   // Get the numbers and insert them into the array.
         TextIO.put("? ");
         num = TextIO.getlnDouble();
         if (num &lt;= 0)
            break;
         <newcode>insert(numbers, numCt, num);</newcode>
         numCt++;
      }
      
      TextIO.putln("\nYour numbers in sorted order are:\n");
    
      for (int i = 0; i &lt; numCt; i++) {
          TextIO.putln( numbers[i] );
      }
    
   } // end main();
   
   /**
    * Assume that A contains itemsInArray in increasing order.
    * Insert newItem into its correct position in the sorted array.
    */
   static void insert(double[] A, int itemsInArray, double newItem) {
      int loc = itemsInArray - 1;
      while (loc &gt;= 0 &amp;&amp; A[loc] &gt; newItem) {
             // Move the item from A[loc] up one space.
         A[loc + 1] = A[loc];
         loc = loc - 1;
      }
      A[loc + 1] = newItem;  // Put newItem in the last vacated space.
   } // end insert
  
}  // end class SortInputNumbers
</pre>
</exercise-code>
</exercise>   

   
   
<exercise>
<exercise-question><p> A <newword>polygon</newword> 
is a geometric figure made up of a sequence of
connected line segments. The points where the line segments meet are called the
<newword>vertices</newword> of the polygon. The <classname>Graphics</classname>
class includes commands for drawing and filling polygons. For these commands,
the coordinates of the vertices of the polygon are stored in arrays. If
<code>g</code> is a variable of type <classname>Graphics</classname> then</p>
<ul>
<li><codedef>g.drawPolygon(xCoords, yCoords,
pointCt)</codedef> will draw the outline of the polygon with vertices at the points
<code>(xCoords[0],yCoords[0])</code>, <code>(xCoords[1],yCoords[1])</code>, &dots;,
<code>(xCoords[pointCt-1],yCoords[pointCt-1])</code>. The third parameter,
<code>pointCt</code>, is an <ptype>int</ptype> that specifies the number of vertices of
the polygon. Its value should be 3 or greater. The first two parameters are
arrays of type <code>int[]</code>. Note that the polygon automatically includes a
line from the last point, <code>(xCoords[pointCt-1],yCoords[pointCt-1])</code>,
back to the starting point <code>(xCoords[0],yCoords[0])</code>.</li>
<li><codedef>g.fillPolygon(xCoords, yCoords,
pointCt)</codedef> fills the interior of the polygon with the current drawing
color. The parameters have the same meaning as in the <code>drawPolygon()</code>
method. Note that it is OK for the sides of the polygon to cross each other,
but the interior of a polygon with self-intersections might not be exactly what
you expect.</li>
</ul>
<p>Write a panel class that lets the user draw polygons, and use your panel
as the content pane in an applet (or standalone application).  As the user clicks a
sequence of points, count them and store their x- and y-coordinates in two
arrays. These points will be the vertices of the polygon. Also, draw a line
between each consecutive pair of points to give the user some visual feedback.
When the user clicks near the starting point, draw the complete polygon. Draw
it with a red interior and a black border. The user should then be able to
start drawing a new polygon. When the user shift-clicks on the applet, clear
it.</p>
<p>For this exercise, there is no need to store information about the contents of the 
applet.  Do the drawing directly in the <code>mousePressed()</code> routine, and use
the <code>getGraphics()</code> method to get a <classname>Graphics</classname> object
that you can use to draw the line.  (Remember, though, that this is considered to be
bad style.)  You will not need a <code>paintComponent()</code> method, since
the default action of filling the panel with its background color is good
enough.</p>

<p><tex>Here is a picture of my solution after the user has drawn a few
polygons:</tex><web>You can try my solution here. Note that as the user is drawing the polygon, lines
are drawn between the points that the user clicks. Click within two pixels of
the starting point to see a filled polygon.</web></p>

<applet code="SimplePolygons.class" archive="SimplePolygons.jar" width="300" height="300"
   alt="Applet 'SimplePolygons' should appear here." tex="SimplePolygons.eps" texscale="0.6"/>
</exercise-question>
<exercise-discuss><p>For my solution, I wrote a subclass of <classname>JApplet</classname>
and used a nested class named <classname>Display</classname> to represent the panel
on which the drawing is done. The
only method in the main class is the <code>init()</code> method, which creates the
drawing surface of type <classname>Display</classname> and uses it as the content pane of the applet.
My discussion here is about <classname>Display</classname>.</p>

<p>The program needs several instance variables to store information about the
sequence of points that the user has clicked:</p>

<pre>int[] xCoord, yCoord;  // Arrays to hold the coordinates.
int pointCt;           // Number of points in the arrays.</pre>

<np>The arrays <code>xCoord</code> and <code>yCoord</code> are examples of "partially
full arrays", as covered in <localref href="arrays.3.1"/>. The variable
<code>pointCt</code> keeps track of how many spaces in the array are used. 
There are, of course, other ways to represent the data, such as using a single
array of <classname>Point</classname>, or using an <classname>ArrayList</classname>.
However, the statement of the problem asked for two arrays.
The instance variables are initialized in the constructor of the <code>Display</code>
with the commands:</np>

<pre>xCoord = new int[500];
yCoord = new int[500];
pointCt = 0;</pre>

<p>The size of the arrays allows for polygons with up to 500 vertices, which
should certainly be enough. When we start, there are not yet any points in the
array, so <code>pointCt</code> is zero. (The command to set <code>pointCt</code> to
zero is not really necessary, since <code>pointCt</code>, as an instance variable,
is automatically initialized to zero in any case. However, including this
command seemed to me to make my intentions clearer to the reader. That should
always be a consideration.)</p>

<p>In my solution, I included a method to draw a line and a method to
draw a polygon. These methods are called in the <code>mousePressed()</code>
routine. Since the lines and polygons are drawn directly, rather than in the
<code>paintComponent()</code> method, these methods are responsible for
obtaining graphics contexts to do the drawing. The <code>putLine</code> method is
simple:</p>

<pre>private void putLine(int x1, int y1, int x2, int y2) {
       // Draw a line from (x1,y1) to (x2,y2) directly onto this
       // component, without going through the paintComponent() 
       // method.
    Graphics g = getGraphics();
    g.drawLine(x1,y1,x2,y2);
    g.dispose();
}</pre>

<p>The <code>putPolygon()</code> method uses the data for the polygon that is
stored in the instance variables <code>xCoord</code>, <code>yCoord</code>, and
<code>pointCt</code>. It is complicated a little by the fact that three points are
required to draw a polygon. If there are only two points stored in the arrays,
then I just draw a line between the two points. Note that the two points are
stored in the first two locations in the <code>xCoord</code> and <code>yCoord</code>
arrays. The coordinates of the two points are <code>(xCoord[0],yCoord[0])</code>
and <code>(xCoord[1],yCoord[1])</code>. If there are fewer than two points, I don't
draw anything. If there are three or more points, then I first draw the
interior of the polygon in red and then draw the outline of the polygon in
black:</p>

<pre>/**
 * Draw the polygon described by the arrays xCoord and yCoord
 * and the integer pointCt.  A filled polygon with a black 
 * outline is drawn.  If pointCt is 0 or 1, nothing is drawn.
 * If pointCt is 2, only a black line is drawn.
 */
private void putPolygon() {
   if (pointCt &lt; 2)
      return;
   Graphics g = getGraphics();
   if (pointCt == 2) {
      g.setColor(Color.BLACK);
      g.drawLine(xCoord[0], yCoord[0], xCoord[1], yCoord[1]);
   }
   else {
      g.setColor(polygonColor);  // (polygonColor has value Color.RED)
      g.fillPolygon(xCoord, yCoord, pointCt);
      g.setColor(Color.BLACK);
      g.drawPolygon(xCoord, yCoord, pointCt);
   }
   g.dispose();
}</pre>

<p>The main logic of the applet is in the <code>mousePressed()</code> method. An
algorithm for this method is:</p>

<pre>if the user was holding down the Shift key:
    Clear the applet, and start a new polygon
else if the user clicked near the first point:
    Draw the current polygon and start a new one
else
    Add the point (evt.getX(), evt.getY()) to the coordinate arrays
    if this is not the first point in the arrays:
        Draw a line between the previous point and this one</pre>

<p>Actually, in my solution, I decided to add another case: If the user
right-clicks the applet or if the number of points reaches 500, then I draw the
current polygon and start a new one. Also, there is a <b>bug</b> in the algorithm as
stated, where it tests "if the user clicked near the first point". This test
doesn't make sense unless there actually is a first point, that is unless
<code>pointCt</code> is greater than zero. The test should really read "if
<code>pointCt</code> &gt; 0 and if the user clicked near
<code>(xCoord[0],yCoord[0])</code>."</p>

<p>Where the algorithm says "start a new polygon", it is only necessary to say
"<code>pointCt&nbsp;=&nbsp;0;</code>" since that will indicate that the coordinate arrays
contain no valid data. The command "draw the current polygon" can be translated
as "<code>putPolygon()</code>". Adding a point to the coordinate arrays means
putting the coordinates of the point in the next available location of the
arrays and incrementing <code>pointCt</code> to record the fact that the number of
valid data in the arrays has increased by one. This is done with the
commands</p>

<pre>xCoord[pointCt] = evt.getX();
yCoord[pointCt] = evt.getY();
pointCt++;</pre>

<np>Then, if <code>pointCt</code> is greater than 1, we have to draw a line between
the last two points in the array. The coordinates of these points are
<code>(xCoord[pointCt-2],yCoord[pointCt-2])</code> and
<code>(xCoord[pointCt-1],yCoord[pointCt-1])</code>, so this can be done with the
command</np>

<pre>putLine(xCoord[pointCt-2], yCoord[pointCt-2],
                 xCoord[pointCt-1], yCoord[pointCt-1] );</pre>

<p>The only thing in the algorithm that still needs implementing is to test
whether the user clicks "near the starting point". The starting point has
coordinates <code>(xCoord[0],yCoord[0])</code> and the point where the user clicked
has coordinates <code>(evt.getX(),evt.getY())</code>. In my applet, I check whether
the <code>x</code>-coordinates of these points are two pixels or less apart and the
<code>y</code>-coordinates are also two pixels or less apart. This is done by
checking whether "<code>Math.abs(xCoord[0]&nbsp;-&nbsp;evt.getX()) &lt;= 2 &amp;&amp;
Math.abs(yCoord[0]&nbsp;-&nbsp;evt.getY()) &lt;= 2</code>". If you are uncomfortable with
absolute values, you can use the equivalent test "<code>(evt.getX()&nbsp;-&nbsp;2 &lt;=
xCoords[0]) &amp;&amp; (xCoords[0] &lt;= evt.getX()&nbsp;+&nbsp;2) &amp;&amp; 
(evt.getY()&nbsp;-&nbsp;2 &lt;= yCoords[0]) &amp;&amp; (yCoords[0] &lt;= evt.getY()&nbsp;+&nbsp;2)</code>".</p>

<p>The complete program for the applet is shown below.</p>

<p>(By the way, there are versions of the <code>drawPolygon()</code> and
<code>fillPolygon()</code> methods that work with objects belonging to a class
called <classname>Polygon</classname>, instead of with arrays. So, you don't absolutely need
arrays to work with polygons.)</p>
</exercise-discuss>
<exercise-code>
<pre>import java.awt.*;
import java.awt.event.*;
import javax.swing.*;


/**
 * This applet lets the user draw colored polygons.
 * The user inputs a polygon by clicking a series of points.
 * Clicking near the starting point (within 2 pixels) or
 * right-clicking (or Command-clicking) will complete the
 * polygon, so the user can begin a new one.  Shift-clicking
 * will clear the screen.  Up to 500 points are allowed in a
 * polygon.  This applet does not keep a copy of the image
 * on the screen, so it will not reappear if the applet is
 * covered and then uncovered.  The drawing done in this
 * applet, using getGraphics() is considered to be bad style.
 *    Note that this class contains a main program, which
 * just opens a window that shows the same type of panel that
 * is shown by the applet. 
 */
public class SimplePolygons extends JApplet {
   
   /**
    * main() routine just shows a panel of type Display as its content pane.
    * This main routine has nothing to do with the function of this class
    * as an applet; it just makes it possible to run the class as a stand-
    * alone application.
    */
   public static void main(String[] args) {
      JFrame window = new JFrame("SimplePolygons");
      Display content = new Display();
      window.setContentPane(content);
      window.pack();
      window.setLocation(100,100);
      window.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
      window.setResizable(false);  
      window.setVisible(true);
   }
   
   /**
    * This simple init() method just creates a drawing surface
    * belonging to the nested class Display and uses it for
    * the content pane of the applet. 
    */
   public void init() {
      setContentPane( new Display() );
   }
   
   
   /**
    * This private class does all the work of the program.  It represents
    * the drawing surface where the user draws the polygons.  It listens
    * for mouse events on itself.
    */
   private static class Display extends JPanel implements MouseListener {
      
      /* Variables for implementing polygon input. */
      
      private int[] xCoord, yCoord;  // Arrays containing the points of 
                                     //   the polygon.  Up to 500 points 
                                     //   are allowed.
      
      private int pointCt;  // The number of points that have been input.
      
      private final static Color polygonColor = Color.RED;  
                                // Color that is used to draw the polygons.  
      
      
      /**
       * Initialize the panel and its data; add a black border and set
       * the panel to listen for mouse events on itself.  Also sets
       * the preferred size of the panel to be 300-by-300.
       */
      public Display() {
         setBackground(Color.WHITE);
         setBorder(BorderFactory.createLineBorder(Color.BLACK,1));
         setPreferredSize( new Dimension(300,300) );
         addMouseListener(this);
         xCoord = new int[500];
         yCoord = new int[500];
         pointCt = 0;
      }
      
         
      /**
       * Draw a line from (x1,y1) to (x2,y2) directly onto this
       * component, without going through the paintComponent() 
       * method.
       */
      private void putLine(int x1, int y1, int x2, int y2) {
         Graphics g = getGraphics();
         g.setColor(Color.BLACK);
         g.drawLine(x1,y1,x2,y2);
         g.dispose();
      }
      
      /**
       * Draw the polygon described by the arrays xCoord and yCoord
       * and the integer pointCt.  A filled polygon with a black 
       * outline is drawn.  If pointCt is 0 or 1, nothing is drawn.
       * If pointCt is 2, only a black line is drawn.
       */
      private void putPolygon() {
         if (pointCt &lt; 2)
            return;
         Graphics g = getGraphics();
         if (pointCt == 2) {
            g.setColor(Color.BLACK);
            g.drawLine(xCoord[0], yCoord[0], xCoord[1], yCoord[1]);
         }
         else {
            g.setColor(polygonColor);
            g.fillPolygon(xCoord, yCoord, pointCt);
            g.setColor(Color.BLACK);
            g.drawPolygon(xCoord, yCoord, pointCt);
         }
         g.dispose();
      }
      
      
      /**
       * Processes a mouse click.
       */
      public void mousePressed(MouseEvent evt) { 
         
         if (evt.isShiftDown()) {
               // Clear the applet. (This only requires a repaint.)
               // Also, set pointCt to zero to start a new polygon.
            pointCt = 0;
            repaint();
         }
         else if ( pointCt > 0 &amp;&amp; (Math.abs(xCoord[0] - evt.getX()) &lt;= 2)
                              &amp;&amp; (Math.abs(yCoord[0] - evt.getY()) &lt;= 2) ) {
               // User has clicked near the starting point.
               // Draw the polygon and reset pointCt so that the 
               // user can start a new polygon.
            putPolygon();
            pointCt = 0;
         }
         else if (evt.isMetaDown() || pointCt == 500) {
               // Draw the polygon and reset pointCt so that the 
               // user can start a new polygon.  Note that there
               // is a limit of 500 points for one polygon.
            putPolygon();
            pointCt = 0;
         }
         else {
               // Add the point where the user clicked to the list of
               // points in the polygon, and draw a line between the
               // previous point and the current point.  A line can
               // only be drawn if there are at least two points.
            xCoord[pointCt] = evt.getX();
            yCoord[pointCt] = evt.getY();
            pointCt++;
            if (pointCt >= 2) {
               putLine(xCoord[pointCt-2], yCoord[pointCt-2], 
                     xCoord[pointCt-1], yCoord[pointCt-1]); 
            }
         }
         
      } // end mousePressed()
      
      public void mouseReleased(MouseEvent evt) { }
      public void mouseClicked(MouseEvent evt) { }
      public void mouseEntered(MouseEvent evt) { }
      public void mouseExited(MouseEvent evt) { }
      
   } // end nested class Display
   
   
}  // end class SimplePolygons
</pre>
</exercise-code>
</exercise>
   
   
   
<exercise>
<exercise-question><p>For this problem, you will
need to use an array of objects. The objects belong to the class
<classname>MovingBall</classname>, which I have already written. You can find the source code
for this class in the file <sourceref href="MovingBall.java"/>. A <classname>MovingBall</classname>
represents a circle that has an associated color, radius, direction, and speed.
It is restricted to moving inside some rectangle in the <code>(x,y)</code> plane. It will
"bounce back" when it hits one of the sides of this rectangle. A
<classname>MovingBall</classname> does not actually move by itself. It's just a collection of
data. You have to call instance methods to tell it to update its position and
to draw itself. The constructor for the <classname>MovingBall</classname> class takes the
form</p>

<pre>new MovingBall(xmin, xmax, ymin, ymax)</pre>

<np>where the parameters are integers that specify the limits on the <code>x</code>
and <code>y</code> coordinates of the ball.  (This sets the rectangle inside which the ball
will stay.)  In this exercise, you will want balls
to bounce off the sides of the applet, so you will create them with the
constructor call</np>
   
<pre>new MovingBall(0, getWidth(), 0, getHeight())</pre> 

<np>The constructor creates a ball that initially is colored red, has a radius of 5
pixels, is located at the center of its range, has a random speed between 4 and
12, and is headed in a random direction. There is one <b>problem</b> here:  You
can't use this constructor until the width and height of the component are known.
It would be OK to use it in the <code>init()</code> method of an applet, but not
in the constructor of an applet or panel class.  If you are using a panel class to
display the ball, one slightly messy solution is to create the <classname>MovingBall</classname> 
objects in the panel's <code>paintComponent()</code> method the first time that method
is called.  You can be sure that the size of the panel has been determined before
<code>paintComponent()</code> is called.  This is what I did in my own solution to
this exercise.</np>
   
<p>If <code>ball</code> is a variable of type
<classname>MovingBall</classname>, then the following methods are available:</p>
   
<ul>
<li><codedef>ball.draw(g)</codedef> &mdash; draw the ball in a
graphics context. The parameter, <code>g</code>, must be of type <code>Graphics</code>.
(The drawing color in <code>g</code> will be changed to the color of the
ball.)</li>
<li><codedef>ball.travel()</codedef> &mdash; change the
<code>(x,y)-</code>coordinates of the ball by an amount equal to its speed. The
ball has a certain direction of motion, and the ball is moved in that
direction. Ordinarily, you will call this once for each frame of an animation,
so the speed is given in terms of "pixels per frame". Calling this routine does
not move the ball on the screen. It just changes the values of some instance
variables in the object. The next time the object's <code>draw()</code> method is
called, the ball will be drawn in the new position.</li>
<li><codedef>ball.headTowards(x,y)</codedef> &mdash; change the
direction of motion of the ball so that it is headed towards the point
<code>(x,y)</code>. This does not affect the speed.</li>
</ul>
<np>These are the methods that you will need for this exercise. There are also
methods for setting various properties of the ball, such as 
<code>ball.setColor(color)</code> for changing the color and
<code>ball.setRadius(radius)</code> for changing its
size. See the source code for more information.
A nice variation on the exercise would be to use random
colors and sizes for the balls.  </np>

<p>For this exercise, you should create an applet that shows an animation of
balls bouncing around on a black background. Use a <classname>Timer</classname>
to drive the animation.  (See <localref href="GUI1.5.1"/>.)  Use an array of
type <code>MovingBall[]</code> to hold the data for the balls.
In addition, your program should listen for mouse and mouse motion events. 
When the user presses the mouse or
drags the mouse, call each of the ball's <code>headTowards()</code> methods to make
the balls head towards the mouse's location.
My solution uses 50 balls and a time delay of 50 milliseconds for the timer.</p>
<webdiv>
<p>Here is my solution. Try clicking and dragging on the applet:</p>
<applet code="BallisticBalls.class" archive="BallisticBalls.jar" width="400" height="300"/>
</webdiv>
</exercise-question>
<exercise-discuss><p>The solution to this exercise is not very long, although it 
is rather complicated conceptually and it might take time
to get used to working with arrays of objects.</p>
   
<p>My program uses a nested class named <classname>Display</classname>, defined
as a subclass of <classname>JPanel</classname>, as a drawing surface where the moving
balls are drawn.  The main class is a subclass of <classname>JApplet</classname>, but
it just uses an object of type <classname>Display</classname> as its content pane.
Here, I only discuss the programming of the <classname>Display</classname> class.</p>
    
<p>An instance variable of type
<atype>MovingBall[]</atype> is needed to hold the data for the  balls. This
instance variable can be declared as</p>

<pre>MovingBall[] balls;</pre>

<np>As discussed in the exercise, it is not possible to create the ball objects
in the constructor of the <classname>Display</classname> class, so I create the
array and the ball objects that it contains in <code>paintComponent()</code>.
This should only be done once, the first time <code>paintComponent()</code>
is called.  To achieve this, I test whether <code>balls == null</code> at the
beginning of the <code>paintComponent()</code> method.  If not, then the
objects have already been created; if so, then this is the first time
<code>paintComponent()</code> is being called, and the objects must be
created.  The array object is created with a statement of the form
"<code>balls&nbsp;= new&nbsp;MovingBall[ballCount];</code>" where <code>ballCount</code>
is the number of balls. However, this just gives an array filled with <code>null</code> values. There
aren't any balls yet. Each of the balls must be created with a call to the
constructor from the <code>MovingBall</code> class:</np>

<pre>if (balls == null) {
   balls = new MovingBall[ ballCount ];  // Create the array
   for (int i = 0; i &lt; balls.length; i++) {
         // Create each of the ball objects.  The parameters specify
         // that the balls are restricted to moving within the bounds
         // of the panel.
      balls[i] = new MovingBall(0, getWidth(), 0, getHeight());
   }
}</pre>

<p>The <code>paintComponent()</code> method must draw the balls.  I decided to
put the code for moving the balls into the <code>paintComponent()</code> method
as well.  This means that each ball will move in its current direction of motion
by a small amount each time <code>paintComponent()</code> is called.  The
<code>i</code>-th ball can be moved by calling its <code>travel()</code> method with
the command "<code>balls[i].travel()</code>". It can be drawn in the graphics
context <code>g</code> by calling its <code>draw()</code> method with the command
<code>balls[i].draw(g);</code>". To apply these commands to every ball in the
array, we need a <code>for</code> loop</p>

<pre>for (int i = 0; i &lt; balls.length; i++) {
    balls[i].travel();
    balls[i].draw(g);
}</pre>
   
<np>An alternative to this would be the for-each loop:</np>
   
<pre>for ( MovingBall ball : balls ) {
   ball.travel();
   ball.draw(g);  
}</pre>

<p>Similarly, in the <code>mousePressed()</code> and
<code>mouseDragged()</code> routine, we need a <code>for</code> loop 
(or for-each loop) to tell each ball
to head towards the location of the mouse,
<code>(evt.getX(),evt.getY())</code>:</p>

<pre>for (int i = 0; i &lt; balls.length; i++) {
   balls[i].headTowards(evt.getX(),evt.getY());
}</pre>
   
<np>My program uses anonymous inner classes for the mouse listener and mouse motion
listener.  We also need a timer to drive the animation.  Since the balls move
every time <code>paintComponent()</code> is called, the response to an action event
from the timer is simply to call <code>repaint()</code>, which will in turn cause
<code>paintComponent()</code> to be called.  The action listener for the timer
is also defined by an anonymous inner class:</np>

<pre>Timer timer = new Timer(millisecondsPerFrame, new ActionListener() {
       // This timer will drive the animation by calling repaint()
       // at periodic intervals.
   public void actionPerformed(ActionEvent evt) {
      repaint();
   }
});
timer.start();</pre>

<p>That's really all there is to it. You might want to try variations like
giving the balls random colors or sizes. This can be done when the ball objects
are created in the <code>paintComponent()</code> method. 
In my program, I decided to use applet parameters to
make it possible to customize the applet by specifying the number of balls and
by setting the speed at which the animation plays.
Recall that applet parameters are specified in the
<code>&lt;applet&gt;</code> tag on the web page. The following applet tag specifies
fewer balls, moving more slowly, than the default:</p>

<pre>&lt;applet code="BallisticBalls.class" archive="BallisticBalls.jar" width=400 height=300&gt;
   &lt;param name="frameTime" value="25"&gt;
   &lt;param name="ballCount" value="100"&gt;
&lt;/applet&gt;</pre>

<np>The <code>param</code> with name "ballCount" specifies the number of balls in
the applet. The <code>param</code> with name "frameTime" specifies the number of
milliseconds to use for each frame of the animation. You can look at the source
code for the applet, below, to see how I use these params. The applet's
<code>init()</code> demonstrates how to get an integer value from an applet
param.</np>
</exercise-discuss>
<exercise-code>
<pre>import java.awt.*;
import java.awt.event.*;
import javax.swing.*;


/**
 * This applet shows an animation of red balls moving on a black
 * background.  The balls "bounce" off the sides of the applet.
 * The number of balls can be set as the value of an applet
 * param with name "ballCount".  The default number is 50.
 * The number of milliseconds per frame can be set as the value of an
 * applet parameter with name "frameTime".  The default is 
 * 50 milliseconds. 
 * 
 * If the user clicks on the applet, or drags the mouse on
 * the applet, all the balls head towards the mouse location.
 * 
 * The "balls" are represented by objects of type MovingBall, which
 * is defined in the file MovingBall.java.
 * 
 * This class also contains a main() routine that allows the class
 * to be run as a stand-alone application.
 */
public class BallisticBalls extends JApplet {
   
   
   /**
    * main() routine simply opens a window that uses an object of
    * type Display as its content pane, where Display is a static
    * nested class inside this class.
    */
   public static void main(String[] args) {
      JFrame window = new JFrame("Ballistic Balls");
      Display content = new Display(50,50);
      window.setContentPane(content);
      window.pack();
      window.setLocation(100,100);
      window.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
      window.setResizable(false);  
      window.setVisible(true);
   }
   

   /**
    * The init() method of the applet uses an object of type Display
    * as the content pane of the applet. It also process the
    * applet params named "ballCount" and "frameTime", if present,
    * and uses their values to configure the Display.
    */
   public  void init() {
      
      int millisecondsPerFrame;  // Time between frames in animation.
      int ballCount;             // Number of MovingBalls that are used.
      
      try {
            // Try to read the value of millisecondsPerFrame from
            // an applet parameter named "frameTime".  If it is not
            // present or is not a legal value, an error will occur,
            // and the default value of 50 will be used.
         String str = getParameter("frameTime");
         millisecondsPerFrame = Integer.parseInt(str);
         if (millisecondsPerFrame &lt;= 0)
            millisecondsPerFrame = 50;
      }
      catch (NumberFormatException e) {
         millisecondsPerFrame = 50;  // Use default value.
      }
      
      try {
            // Try to read the value of ballCount from
            // an applet parameter named "ballCount".  If it is not
            // present or is not a legal value, an error will occur,
            // and the default value of 50 will be used.
         String str = getParameter("ballCount");
         ballCount = Integer.parseInt(str);
         if (ballCount &lt;= 0)
            ballCount = 50;
      }
      catch (NumberFormatException e) {
         ballCount = 50;  // Use default value.
      }
      
      setContentPane( new Display(ballCount, millisecondsPerFrame) );
      
   } // end init();
   
   
   
   /**
    * The nested class Display does all the work of the program.
    * It represents the drawing area in which the balls move.
    */
   private static class Display extends JPanel {

      MovingBall[] balls;  // An array to hold the balls.  This will be
                           //    null until the first time paintComponent()
                           //    is called.
      
      int ballCount;       // Number of balls requested in the constructor.
      
      
      /**
       * Constructor sets the background color (black) and preferred size (400-by-400)
       * of the panel.  It sets up mouse listeners and creates and starts a timer
       * that will drive the motion of the balls.
       * @param ballCount  the number of balls that should be used
       * @param millisecondsPerFrame  the time between frames; this becomes
       *    the delay time of the timer that drives the animation.
       */
      Display(int ballCount, int millisecondsPerFrame) {
         
         setBackground(Color.BLACK);
         setPreferredSize( new Dimension(400,400) );
         
         this.ballCount = ballCount;
         
         addMouseListener(new MouseAdapter() {
            public void mousePressed(MouseEvent evt) { 
                  // The user has clicked on the panel.  Tell all the
                  // balls to head towards the location of the mouse.
               for (int i = 0; i &lt; balls.length; i++)
                  balls[i].headTowards(evt.getX(), evt.getY());
            }
         });
         
         addMouseMotionListener(new MouseMotionAdapter() {
            public void mouseDragged(MouseEvent evt) { 
                  // The user has dragged the mouse on the panel.  Tell all
                  // the balls to head towards the location of the mouse.
               for (int i = 0; i &lt; balls.length; i++)
                  balls[i].headTowards(evt.getX(), evt.getY());
            }
            
         });
         
         Timer timer = new Timer(millisecondsPerFrame, new ActionListener() {
                // This timer will drive the animation by calling repaint()
                // at periodic intervals.
            public void actionPerformed(ActionEvent evt) {
               repaint();
            }
         });
         timer.start();

      } // end constructor
      
      
      /**
       * The paint component method moves all the balls along their trajectories
       * (by calling ball.travel() for each ball) and draws all the balls  (by
       * calling ball.draw(g) for each ball).  Thus, the balls move each time
       * paintComponent() is called, and to drive the animation, it is only necessary
       * to call repaint() over-and-over.
       */
      public void paintComponent(Graphics g) {
         
         super.paintComponent(g);
         
         if (balls == null) {
            balls = new MovingBall[ ballCount ];  // Create the array
            for (int i = 0; i &lt; balls.length; i++) {
                  // Create each of the ball objects.  The parameters specify
                  // that the balls are restricted to moving within the bounds
                  // of the panel.  NOTE: This is done in paintComponent() 
                  // because the size of the panel has not yet been set when the
                  // constructor is called.
               balls[i] = new MovingBall(0, getWidth(), 0, getHeight());
            }
         }
         
         /* Tell each ball to move.  It moves an amount depending on
          its current direction and speed, and it will "bounce" off the
          side of the applet if necessary.  Then the ball is told
          to draw itself in the graphics context g.
          */
         
         for (int i = 0; i &lt; balls.length; i++) {
            balls[i].travel();
            balls[i].draw(g);
         }
         
      } // end paintComponent()
      
      
   } // end nested class Display
   
}  // end class BallisticBalls 
</pre>
</exercise-code>
</exercise>
   
   
   
<exercise>
<exercise-question><p>The sample program <sourceref href="RandomArtPanel.java"/> from
<localref href="GUI1.5.1"/> shows a different random "artwork" every four seconds.  There
are three types of "art", one made from lines, one from circles, and one from filled
squares.  However, the program does not save the data for the picture that is shown
on the screen.  As a result, the picture cannot be redrawn when necessary.  In fact, 
every time <code>paintComponent()</code> is called, a new picture is drawn.</p>
<p>Write a new version of <sourceref href="RandomArtPanel.java"/> that saves the
data needed to redraw its pictures.   The <code>paintComponent()</code> method
should simply use the data to draw the picture.  New data should be recomputed
only every four seconds, in response to an event from the timer that drives the
program.</p>
<p>To make this interesting, write a separate class for each of the three different
types of art.  Also write an abstract class to serve as the common base class for
the three classes.  Since all three types of art use a random gray background, 
the background color can be defined in their superclass.  The superclass also
contains a <code>draw()</code> method that draws the picture; this is an abstract
method because its implementation depends on the particular type of art that
is being drawn.  The abstract class can be defined as:</p>
<pre>
private abstract class ArtData {
   Color backgroundColor;  // The background color for the art.
   ArtData() {  // Constructor sets background color to be a random gray.
      int x = (int)(256*Math.random());
      backgroundColor = new Color( x, x, x );
   }
   abstract void draw(Graphics g);  // Draws this artwork.
}</pre>
<p>Each of the three subclasses of <code>ArtData</code> must define its own <code>draw()</code>
method.  It must also define instance variables to hold the data necessary to draw the
picture.  I suggest that you should create random data for the picture in the constructor
of the class, so that  constructing the object will automatically create the data for the random
artwork. (One problem with this is that you can't create the data until you know the
size of the panel, so you can't create an <code>ArtData</code> object in the constructor of the panel.
One solution is to create an <code>ArtData</code> object at the beginning of the <code>paintComponent()</code>
method, if the object has not already been created.)
In all three subclasses, you will need to use several arrays 
to store the data.</p>
<p>The file <sourceref href="RandomArtPanel.java"/> only defines a panel class.  A
main program that uses this panel can be found in <sourceref href="RandomArt.java"/>,
and an applet that uses it can be found in <sourceref href="RandomArtApplet.java"/>.
You only need to modify <classname>RandomArtPanel</classname>.</p>
</exercise-question>
<exercise-discuss><p>In my solution, I defined subclasses <classname>LineArtData</classname>,
<classname>CircleArtData</classname>, and <classname>SquareArtData</classname> of
the basic abstract <classname>ArtData</classname> class.  An instance variable named
<code>artData</code>, of type <classname>ArtData</classname>, points to the object that
holds the data for the current picture.  When it's time to create a new artwork,
I call the following method, which changes the value of <code>artData</code>.  Note
that this method has an equal chance of producing each of the three types of art:</p>
<pre>/**
 * Creates an object belonging to one of the three subclasses of
 * ArtData, and assigns that object to the instance variable, artData.
 * The subclass to use (that is, the type of art) is chosen at random.
 */
private void createArtData() {
   switch ( (int)(3*Math.random()) ) {
   case 0:
      artData = new LineArtData();
      break;
   case 1:
      artData = new CircleArtData();
      break;
   case 2:
      artData = new SquareArtData();
      break;
   }
}</pre>
<p>This method is called by the action listener that responds to events from the timer,
so a new artwork is created every time the timer generates an event, that is, every four seconds.</p>
<p>The <code>paintComponent()</code> method uses the background color from <code>artData</code>
to fill the drawing area.  It then tells <code>artData</code> to draw itself by calling
its <code>draw()</code> method.  As suggested in the exercise, it first makes sure
that an art data object has been created by calling <code>createArtData()</code> if
<code>artData</code> is still null; this can only be true the first time <code>paintComponent()</code>
is called.  So, the <code>paintComponent()</code> method is quite simple:</p>

<pre>public void paintComponent(Graphics g) {

   if (artData == null)  // If no artdata has yet been created, create it.
      createArtData();
   
   // Note:  Since the next two lines fill the entire panel, there is
   // no need to call super.paintComponent(g), since any drawing
   // that it does will only be covered up anyway.
   
   g.setColor(artData.backgroundColor); // Fill with the art's background color.
   g.fillRect( 0, 0, getWidth(), getHeight() );

   artData.draw(g);  // Draw the art.
     
} // end paintComponent()</pre>

<p>The only thing that remains for discussion is the three classes that define the three
types of art.  Note that we have been able to get this far without thinking about creating
or drawing the actual art.  This is because we have been thinking "abstractly," in terms of the
abstract class.</p>
<p>Let's look in detail at <classname>LineArtData</classname>, one of the three concrete 
subclasses of <classname>ArtData</classname>.  In the original program, line art was
drawn in the <code>paintComponent()</code> method as follows:</p>
<pre>for (int i = 0; i &lt; 500; i++) {
   int x1 = (int)(getWidth() * Math.random());
   int y1 = (int)(getHeight() * Math.random());
   int x2 = (int)(getWidth() * Math.random());
   int y2 = (int)(getHeight() * Math.random());
   Color randomHue = Color.getHSBColor( (float)Math.random(), 1.0F, 1.0F);
   g.setColor(randomHue);
   g.drawLine(x1,y1,x2,y2);
}</pre>
<np>Here, the coordinates and colors for each line are chosen at random and the line is immediately
drawn using that data.  For the new version, we want to save the data in instance variables
so that the picture can be drawn and redrawn on demand.  The creation of the data will be split
from the drawing; the data will be created in the constructor and will be used to draw the
picture in the <code>draw()</code> method.   To save the data for all 500 lines,
we have to store the coordinates and colors in arrays.  There are several ways to do this,
but I used one array for each piece of data, <code>x1</code>, <code>y1</code>, <code>x2</code>,
<code>y2</code>, and the color.  
To store data for 500 lines, each array should be of length
500.  For example, <code>x1</code> is declared as an instance variable of type
<atype>int[]</atype>, and the array is created with the command "<code>x1 = new&nbsp;int[500];</code>".
The arrays are created in the <classname>LineArtData</classname> constructor and are filled with random data.
In the <code>draw()</code> method, the <code>i-th</code> line can be drawn with the commands:</np>
<pre>g.setColor( color[i] );    // Use the i-th color in the array
g.drawLine( x1[i], y1[i], x2[i], y2[i] );</pre>
<np>We just need a <code>for</code> loop to draw all the lines.  The complete definition of
<classname>LineArtData</classname> class is as follows:</np>
<pre>/**
 * Stores data for a picture that contains 500 random lines drawn in
 * different random colors.
 */
private class LineArtData extends ArtData {
   Color[] color;         // color[i] is the color of line number i
   int[] x1, y1, x2, y2;  // line i goes from (x1[i],y1[i]) to (x2[i],y2[i]).
   LineArtData() {  // Constructor creates arrays and fills then randomly.
      color = new Color[500];
      x1 = new int[500];
      y1 = new int[500];
      x2 = new int[500];
      y2 = new int[500];
      for (int i = 0; i &lt; 500; i++) {
         x1[i] = (int)(getWidth() * Math.random());
         y1[i] = (int)(getHeight() * Math.random());
         x2[i] = (int)(getWidth() * Math.random());
         y2[i] = (int)(getHeight() * Math.random());
         color[i] = Color.getHSBColor( (float)Math.random(), 1.0F, 1.0F);
      }
   }
   void draw(Graphics g) {  // Draw the picture.
      for (int i = 0; i &lt; 500; i++) {
         g.setColor(color[i]);
         g.drawLine( x1[i], y1[i], x2[i], y2[i] );
      }
   }
}</pre>
<np>This is, by the way, a <b>non-static</b> nested class in the <classname>RandomArtPanel</classname>
class.  It can't be static because it uses the instance methods <code>getWidth()</code> and
<code>getHeight()</code> from the containing class.</np>
<p>The other two classes are very similar.  Note that we are using the technique of 
"parallel arrays" here.  That is, the data for the <code>i-th</code> line is spread out
over five different arrays.  An array of objects, where each object holds all the data
for one line, might be better style but it seemed to be overkill for this
simple example.</p>
</exercise-discuss>
<exercise-code>
<pre>import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

/**
 * A RandomArtPanel draws random pictures which might be taken to have
 * some vague resemblance to abstract art.  A new picture is produced every
 * four seconds.  There are three types of pictures:  random lines,
 * random circles, and random 3D rects.  The figures are drawn in
 * random colors on a background that is a random shade of gray.  The
 * data for a given piece of art is stored in a data structure so
 * that the picture can be redrawn if necessary.  The data is created
 * in response to the action event from a timer.
 */
public class RandomArtPanel2 extends JPanel {
   
   /**
    * The data for the currently displayed picture (unless it is null).
    */
   private ArtData artData;
   
   
   /**
    * The constructor creates a timer with a delay time of four seconds
    * (4000 milliseconds), and with a RepaintAction object as its
    * ActionListener.  It also starts the timer running.  The
    * RepaintAction class is a nested class, defined below.
    */
   public RandomArtPanel2() {
      RepaintAction action = new RepaintAction();
      Timer timer = new Timer(4000, action);
      timer.start();
   }

   
   /**
    * The paintComponent() method fills the panel with a random shade of
    * gray and then draws one of three types of random "art".  The data for
    * the picture is in the variable artData (if this variable is null,
    * then an artData object is created here).
    */
   public void paintComponent(Graphics g) {

      if (artData == null)  // If no artdata has yet been created, create it.
         createArtData();
      
      // Note:  Since the next two lines fill the entire panel, there is
      // no need to call super.paintComponent(g), since any drawing
      // that it does will only be covered up anyway.
      
      g.setColor(artData.backgroundColor); // Fill with the art's background color.
      g.fillRect( 0, 0, getWidth(), getHeight() );

      artData.draw(g);  // Draw the art.
        
   } // end paintComponent()
   
   
   /**
    * Creates an object belonging to one of the three subclasses of
    * ArtData, and assigns that object to the instance variable, artData.
    * The subclass to use (that is, the type of art) is chosen at random.
    */
   private void createArtData() {
      switch ( (int)(3*Math.random()) ) {
      case 0:
         artData = new LineArtData();
         break;
      case 1:
         artData = new CircleArtData();
         break;
      case 2:
         artData = new SquareArtData();
         break;
      }
   }
   
   
   /**
    * An abstract class that represents the data for a random work
    * of "art".  Different concrete subclasses of this class represent
    * different types of art.  This class contains a background
    * color which is a random shade of gray, selected when the object
    * is constructed.
    */
   private abstract class ArtData {
      Color backgroundColor;  // The background color for the art.
      ArtData() {  // Constructor sets background color to be a random shade of gray.
         int x = (int)(256*Math.random());
         backgroundColor = new Color( x, x, x );
      }
      abstract void draw(Graphics g);  // Draw the picture.
   }
   
   
   /**
    * Stores data for a picture that contains 500 random lines drawn in
    * different random colors.
    */
   private class LineArtData extends ArtData {
      Color[] color;         // color[i] is the color of line number i
      int[] x1, y1, x2, y2;  // line i goes from (x1[i],y1[i]) to (x2[i],y2[i]).
      LineArtData() {  // Constructor creates arrays and fills then randomly.
         color = new Color[500];
         x1 = new int[500];
         y1 = new int[500];
         x2 = new int[500];
         y2 = new int[500];
         for (int i = 0; i &lt; 500; i++) {
            x1[i] = (int)(getWidth() * Math.random());
            y1[i] = (int)(getHeight() * Math.random());
            x2[i] = (int)(getWidth() * Math.random());
            y2[i] = (int)(getHeight() * Math.random());
            color[i] = Color.getHSBColor( (float)Math.random(), 1.0F, 1.0F);
         }
      }
      void draw(Graphics g) {  // Draw the picture.
         for (int i = 0; i &lt; 500; i++) {
            g.setColor(color[i]);
            g.drawLine( x1[i], y1[i], x2[i], y2[i] );
         }
      }
   }
   
   
   /**
    * Stores data for a picture that contains 200 circles with 
    * radius 50, with random centers, and drawn in random colors.
    */
   private class CircleArtData extends ArtData {
      Color[] color;  // color[i] is the color of the i-th circle
      int[] centerX;  // center of circle i is at (centerX[i], centerY[i])
      int[] centerY;
      CircleArtData() {  // Constructor creates arrays and fills then randomly.
         color = new Color[200];
         centerX = new int[200];
         centerY = new int[200];
         for (int i = 0; i &lt; 200; i++) {
            centerX[i] =  (int)(getWidth() * Math.random());
            centerY[i] = (int)(getHeight() * Math.random());
            color[i] = Color.getHSBColor( (float)Math.random(), 1.0F, 1.0F);
         }
      }
      void draw(Graphics g) {  // Draw the picture.
         for (int i = 0; i &lt; 200; i++) {
            g.setColor(color[i]);
            g.drawOval(centerX[i] - 50, centerY[i] - 50, 100, 100);
         }
      }
   }
   
   
   /**
    * Stores data for a picture that contains 25 filled squares with 
    * random sizes and  with random centers, and drawn in random colors.
    */
   private class SquareArtData extends ArtData {
      Color[] color;  // color[i] is the color of the i-th square
      int[] centerX;  // the center of square i is (centerX[i], centerY[i])
      int[] centerY; 
      int[] size;     // size[i] is the length of the side of the i-th square
      SquareArtData() {  // Constructor creates arrays and fills then randomly.
         color = new Color[25];
         centerX = new int[25];
         centerY = new int[25];
         size = new int[25];
         for (int i = 0; i &lt; 25; i++) {
            centerX[i] =  (int)(getWidth() * Math.random());
            centerY[i] = (int)(getHeight() * Math.random());
            size[i] = 30 + (int)(170*Math.random());
            color[i] = new Color( (int)(256*Math.random()), 
                  (int)(256*Math.random()), (int)(256*Math.random()) );
         }
      }
      void draw(Graphics g) {  // Draw the picture.
         for (int i = 0; i &lt; 25; i++) {
            g.setColor(color[i]);
            g.fill3DRect(centerX[i] - size[i]/2, centerY[i] - size[i]/2, 
                  size[i], size[i], true);
         }
      }
   }
   

   /**
    * A RepaintAction object creates a new artData object and calls the repaint 
    * method of this panel each time its actionPerformed() method is called.  
    * An object of this type is used as an action listener for a Timer that 
    * generates an ActionEvent every four seconds.  The result is a new work of
    * art every four seconds.
    */
   private class RepaintAction implements ActionListener {
      public void actionPerformed(ActionEvent evt) {
         createArtData();
         repaint();
      }
   }
   
   
} // end class RandomArtPanel2
</pre>
</exercise-code>
</exercise>
   
   
   
<exercise id="arrays.ex.6">
<exercise-question><p>Write a program that will read a text file selected by the user,
and will make an alphabetical list of all the different words in that file.  All words
should be converted to lower case, and duplicates should be eliminated from the list.
The list should be written to an output file selected by the user.  As discussed
in <localref href="basics.4.5"/>, you can use <classname>TextIO</classname> to read and
write files.  Use a variable of type <atype>ArrayList&lt;String&gt;</atype> to
store the words.  (See <localref href="arrays.3.4"/>.)
It is not easy to separate a file into words as you are reading
it.  You can use the following method:</p>
<pre>/**
 * Read the next word from TextIO, if there is one.  First, skip past
 * any non-letters in the input.  If an end-of-file is encountered before 
 * a word is found, return null.  Otherwise, read and return the word.
 * A word is defined as a sequence of letters.  Also, a word can include
 * an apostrophe if the apostrophe is surrounded by letters on each side.
 * @return the next word from TextIO, or null if an end-of-file is 
 * encountered
 */
private static String readNextWord() {
   char ch = TextIO.peek(); // Look at next character in input.
   while (ch != TextIO.EOF &amp;&amp; ! Character.isLetter(ch)) {
          // Skip past non-letters.
      TextIO.getAnyChar();  // Read the character.
      ch = TextIO.peek();   // Look at the next character.
   }
   if (ch == TextIO.EOF) // Encountered end-of-file
      return null;
   // At this point, we know the next character is a letter, so read a word.
   String word = "";  // This will be the word that is read.
   while (true) {
      word += TextIO.getAnyChar();  // Append the letter onto word.
      ch = TextIO.peek();  // Look at next character.
      if ( ch == '\'' ) {
            // The next character is an apostrophe.  Read it, and
            // if the following character is a letter, add both the
            // apostrophe and the letter onto the word and continue
            // reading the word.  If the character after the apostrophe
            // is not a letter, the word is done, so break out of the loop.
         TextIO.getAnyChar();   // Read the apostrophe.
         ch = TextIO.peek();    // Look at char that follows apostrophe.
         if (Character.isLetter(ch)) {
            word += "\'" + TextIO.getAnyChar();
            ch = TextIO.peek();  // Look at next char.
         }
         else
            break;
      }
      if ( ! Character.isLetter(ch) ) {
            // If the next character is not a letter, the word is
            // finished, so break out of the loop.
         break;
      }
      // If we haven't broken out of the loop, next char is a letter.
   }
   return word;  // Return the word that has been read.
}</pre>
<np>Note that this method will return <code>null</code> when the file has been
entirely read.  You can use this as a signal to stop processing the input file.</np>
</exercise-question>
<exercise-discuss><p>This is actually not a very difficult program to write.
The main point of the exercise is to get you to use a list of strings and
to do something with files.</p>
<p>There are several possible approaches to this problem.  One approach is to simply dump
all the words from the file into a list, without worrying about eliminating
duplicates or keeping the list in order.  After the file has been read, the list
can be sorted and printed.  Although the list can contain duplicates, the output
file should list each word only once.  However, it's easy to leave out the duplicates
as the file is being written.  If <code>wordList</code> is the variable of
type <atype>ArrayList&lt;String&gt;</atype> that holds the already sorted list of words,
then the following code will output the list without duplicates.  The idea is
that a word is written only if it is different from the previous word in the list.
Word number 0 is a special case, because there is no previous location in the list
in that case:</p>
<pre>for (int i = 0; i &lt; wordlist.size(); i++) {
   if (i == 0 || ! wordlist.get(i).equals(wordList.get(i-1) )  
      TextIO.putln(wordlist.get(i));
}</pre>
<p>A second approach to the problem would be to keep the list of words in sorted
order as it is being constructed.  This can be done by applying the <code>insert()</code>
routine from <localref href="arrays.4.3"/> to insert each word into the list.</p>
<p>A third approach, and the one that I use in my solution, is to eliminate duplicates
from the list as it being constructed.  Each time a word is read from the input file,
I first check whether the word is already in the list.  If so, I discard it; if not,
I add it to the end of the list.  The function <code>wordList.indexOf(word)</code>
can be used to test whether a given word is already in the list; this function returns
the value <code>-1</code> if <code>word</code> is not in the list.  After the
input file has been read, the list contains one copy of each word that was found
in the file.  At this point the list still has to be sorted.  I use a
selection sort algorithm (<localref href="arrays.4.4"/>) to do the sorting.
Then, all the elements of the list are output using a for-each loop:</p>
<pre>for (String w : wordList)
   TextIO.putln("   " + w);</pre>
<p>To let the user select the input and the output files, I use the methods
<code>TextIO.readUserSelectedFile()</code> and <code>TextIO.writeUserSelectedFile()</code>,
which are discussed in <localref href="basics.4.5"/>.  These methods put up a file
dialog where the user can select a file.  After the user selects an input file, <code>TextIO</code>
reads from that file instead of from the user's input.  After the user selects an output
file, <code>TextIO</code> writes to that file instead of to standard output.
If the user cancels the input file dialog,  then there is no input file to process, 
so I exit the program.  If the user cancels the output file dialog, I write the list of
words anyway&mdash;it will go to standard output so the user will see it on the screen.</p>
<p>When <code>TextIO</code> is working with files and an error occurs, it will generate
an error of type <classname>IllegalArgumentException</classname>.  My program catches
the error if one occurs, and it prints an error message. An error is not very likely
in this case but one could occur if, for example, the user selects an input file that
the user does not have permission to read.</p>
<p>The complete code for my solution is shown below.</p>
</exercise-discuss>
<exercise-code>
<pre>import java.util.ArrayList;

/**
 * Makes an alphabetical list of all the words in a file selected
 * by the user.  The list can be written to a file.
 */
public class ListAllWordsFromFile {
   
   
   public static void main(String[] args) {
      
      System.out.println("\n\nThis program will ask you to select an input file");
      System.out.println("It will read that file and make an alphabetical");
      System.out.println("list of all the words in the file.  After reading");
      System.out.println("the file, the program asks you to select an output");
      System.out.println("file.  If you select a file, the list of words will");
      System.out.println("be written to that file; if you cancel, the list");
      System.out.println("be written to standard output.  All words are converted");
      System.out.println("lower case, and duplicates are eliminated from the list.\n\n");
      System.out.print("Press return to begin.");
      TextIO.getln();  // Wait for user to press return.
      
      try {
         if (TextIO.readUserSelectedFile() == false) {
            System.out.println("No input file selected.  Exiting.");
             System.exit(1);
         }
         ArrayList&lt;String&gt; wordList = new ArrayList&lt;String&gt;();
         String word = readNextWord();
         while (word != null) {
            word = word.toLowerCase();  // convert word to lower case
            if ( wordList.indexOf(word) == -1 ) {
                  // This is a new word, so add it to the list
               wordList.add(word);
            }
            word = readNextWord();
         }
         System.out.println("Number of different words found in file:  " 
               + wordList.size());
         System.out.println();
         if (wordList.size() == 0) {
            System.out.println("No words found in file.");
            System.out.println("Exiting without saving data.");
            System.exit(0);
         }
         selectionSort(wordList);
         TextIO.writeUserSelectedFile(); // If user cancels, output automatically
                                         // goes to standard output.
         TextIO.putln(wordList.size() + " words found in file:\n");
         for (String w : wordList)
            TextIO.putln("   " + w);
         System.out.println("\n\nDone.\n\n");
      }
      catch (Exception e) {
         System.out.println("Sorry, an error has occurred.");
         System.out.println("Error Message:  " + e.getMessage());
      }
      System.exit(0);  // Might be necessary, because of use of file dialogs.
   }


   /**
    * Sorts a list of strings into lexicographical order, using
    * selection sort and treating the list much like an array.  In this 
    * program, the list only contains words made up of lower case
    * letters, so lexicographic order is the same as alphabetical order.
    */
   private static void selectionSort(ArrayList&lt;String&gt; list) {
      for (int top = list.size() - 1; top &gt; 0; top--) {
         int indexOfBiggest = 0;
         for (int j = 0; j &lt; top; j++) {
            String str = list.get(j);
            if (str.compareTo( list.get(indexOfBiggest) ) > 0) {
               indexOfBiggest = j;
            }
         }
         String temp = list.get(top);
         list.set( top, list.get(indexOfBiggest) );
         list.set( indexOfBiggest, temp );
      }
   }


   /**
    * Read the next word from TextIO, if there is one.  First, skip past
    * any non-letters in the input.  If an end-of-file is encountered before 
    * a word is found, return null.  Otherwise, read and return the word.
    * A word is defined as a sequence of letters.  Also, a word can include
    * an apostrophe if the apostrophe is surrounded by letters on each side.
    * @return the next word from TextIO, or null if an end-of-file is encountered
    */
   private static String readNextWord() {
      char ch = TextIO.peek(); // Look at next character in input.
      while (ch != TextIO.EOF &amp;&amp; ! Character.isLetter(ch)) {
             // Skip past non-letters.
         TextIO.getAnyChar();  // Read the character.
         ch = TextIO.peek();   // Look at the next character.
      }
      if (ch == TextIO.EOF) // Encountered end-of-file
         return null;
      // At this point, we know that the next character, so read a word.
      String word = "";  // This will be the word that is read.
      while (true) {
         word += TextIO.getAnyChar();  // Append the letter onto word.
         ch = TextIO.peek();  // Look at next character.
         if ( ch == '\'' ) {
               // The next character is an apostrophe.  Read it, and
               // if the following character is a letter, add both the
               // apostrophe and the letter onto the word and continue
               // reading the word.  If the character after the apostrophe
               // is not a letter, the word is done, so break out of the loop.
            TextIO.getAnyChar();   // Read the apostrophe.
            ch = TextIO.peek();    // Look at char that follows apostrophe.
            if (Character.isLetter(ch)) {
               word += "\'" + TextIO.getAnyChar();
               ch = TextIO.peek();  // Look at next char.
            }
            else
               break;
         }
         if ( ! Character.isLetter(ch) ) {
               // If the next character is not a letter, the word is
               // finished, so break out of the loop.
            break;
         }
         // If we haven't broken out of the loop, next char is a letter.
      }
      return word;  // Return the word that has been read.
   }
   
}
</pre>
</exercise-code>
</exercise>
   
   

<exercise>
<exercise-question><p>The game of Go Moku (also
known as Pente or Five Stones) is similar to Tic-Tac-Toe, except that it is played
on a much larger board and the object is to get five squares in a row rather
than three. Players take turns placing pieces on a board. A piece can be placed
in any empty square. The first player to get five pieces in a row&mdash;horizontally, 
vertically, or diagonally&mdash;wins. If all squares are filled
before either player wins, then the game is a draw. Write a program that lets
two players play Go Moku against each other.</p>

<p>Your program will be simpler than the <classname>Checkers</classname> program from
<localref href="arrays.5.3"/>. Play alternates strictly between the two players,
and there is no need to highlight the legal moves. You will only need two classes,
a short panel class to set up the interface and a <classname>Board</classname> class to draw
the board and do all the work of the game. Nevertheless, you will probably want
to look at the source code for the checkers program,
<sourceref href="Checkers.java"/>, for ideas about the general
outline of the program.</p>

<p>The hardest part of the program is checking whether the move that a player
makes is a winning move. To do this, you have to look in each of the four
possible directions from the square where the user has placed a piece. You have
to count how many pieces that player has in a row in that direction. If the
number is five or more in any direction, then that player wins. As a hint, here
is part of the code from my applet. This code counts the number of pieces that
the user has in a row in a specified direction. The direction is specified by
two integers, <code>dirX</code> and <code>dirY</code>. The values of these variables
are 0, 1, or -1, and at least one of them is non-zero. For example, to look in
the horizontal direction, <code>dirX</code> is 1 and <code>dirY</code> is 0.</p>

<pre>int ct = 1;  // Number of pieces in a row belonging to the player.

int r, c;    // A row and column to be examined

r = row + dirX;  // Look at square in specified direction.
c = col + dirY;
while ( r &gt;= 0 &amp;&amp; r &lt; 13 &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; 13 
                                  &amp;&amp; board[r][c] == player ) {
        // Square is on the board, and it 
        // contains one of the players' pieces.
   ct++;
   r += dirX;  // Go on to next square in this direction.
   c += dirY;
}

r = row - dirX;  // Now, look in the opposite direction.
c = col - dirY;
while ( r &gt;= 0 &amp;&amp; r &lt; 13 &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; 13 
                                 &amp;&amp; board[r][c] == player ) {
   ct++;
   r -= dirX;   // Go on to next square in this direction.
   c -= dirY;
}</pre>

<p>Here is <tex>a picture of my program</tex><web> an applet version of my program</web>
It uses a 13-by-13 board. You can do the same or use a normal 8-by-8 checkerboard.</p>

<applet code="GoMoku$Applet.class" archive="GoMoku.jar" 
   width="350" height="240" tex="GoMoku.eps" texscale="0.75"/>

</exercise-question>
<exercise-discuss><p>This is a fairly complicated program, but it's possible to design and build
it in stages, testing each stage separately. The first stage, the general
layout of the applet, is already done in the 
<sourceref href="Checkers.java"/> program. With just a few changes, the
main panel class, the layout of the panel, and the button and message
handling come directly from that program. Let's take the rest of the Go Moku
game one stage at a time.</p>

<p>A two-dimensional array is used to store the contents of the board. This
array is of type <atype>int[][]</atype> and is named <code>board</code>. It is defined as
an instance variable in the <classname>Board</classname> class, and it is initialized
in the constructor of that class to be a 13-by-13 array. The value in each
position of the array is one of three constants: <code>EMPTY</code>,
<code>WHITE</code>, or <code>BLACK</code>. When a game begins, each of the entries in
the array is set to empty. When a player clicks on an empty square, the
corresponding entry in the array is changed from <code>EMPTY</code> to the player's
color, <code>BLACK</code> or <code>WHITE</code>. In the <code>paintComponent()</code>
method, the contents of the <code>board</code> array are used to decide what pieces
to draw on the board.</p>



<np><b><u>Drawing the Board</u></b></np>

<p>We need a <code>paintComponent()</code> method for the <classname>Board</classname> class that
can draw the board. The board has 13 rows and 13 columns of spaces. How wide
should the board be? If each square in the board is <code>x</code> pixels wide, we
need a total of <code>13*x</code> pixels just for the spaces. But there are also
lines between the spaces. These require another 12 pixels. And there is a
2-pixel border on each side, for another 4 pixels added to the width. So, with
squares of side <code>x</code>, we need a board that is <code>13*x+16</code> pixels
wide. Since I wanted something about the same size as the original
checkerboard, I choose <code>x</code> to be 12, giving a board width of 172 pixels. The
height is also 172. The dimension of the board is actually set in the constructor for the
main class, which uses a null layout and so has to set the sizes of all the components
that it contains by hand.</p>

<p>The left edge of the <code>col</code>-th column of squares in the board is
<code>2+13*col</code>. This allows for the two-pixel border on the left and for 13
pixels for each of the preceding columns of squares. (That's 12 pixels for the
square plus one pixel for the line between that column and the next.) The lines
between the columns are drawn one pixel to the left of each column, at
<code>x</code> values <code>1&nbsp;+&nbsp;13*i</code>, for <code>i</code> from 1 to 12. Rows work the
same way. To draw a piece in row number <code>row</code> and column number
<code>col</code>, the command</p>

<pre>g.fillOval(3 + 13*col, 3 + 13*row, 10, 10);</pre>

<np>can be used. This allows a one-pixel border between the oval that represents
that piece and the side of the square. In my program, I defined a method to draw
a piece:</np>

<pre>private void drawPiece(Graphics g, int piece, int row, int col) {
   if (piece == WHITE)
      g.setColor(Color.WHITE);
   else
      g.setColor(Color.BLACK);
   g.fillOval(3 + 13*col, 3 + 13*row, 10, 10);
}</pre>

<p>The background of the canvas is gray, so the <code>paintComponent()</code>
method only has to draw the black border around the board, the lines between
the squares, and all the pieces on the board. Remember that the piece in a
given row and column is recorded in the <code>board</code> array as
<code>board[row][col]</code>. The board can be drawn by the following
<code>paintComponent()</code> method:</p>

<pre>public void paintComponent(Graphics g) {

   super.paintComponent(g); // Fill with background color, lightGray.
   
   /* Draw grid lines in dark gray.  */
   
   g.setColor(Color.DARK_GRAY);
   for (int i = 1; i &lt; 13; i++) {
      g.drawLine(1 + 13*i, 0, 1 + 13*i, getSize().height);
      g.drawLine(0, 1 + 13*i, getSize().width, 1 + 13*i);
   }
   
   /* Draw a two-pixel black border around the edges of the board. */

   g.setColor(Color.BLACK;
   g.drawRect(0,0,getSize().width-1,getSize().height-1);
   g.drawRect(1,1,getSize().width-3,getSize().height-3);
   
   /* Draw the pieces that are on the board. */
   
   for (int row = 0; row &lt; 13; row++)
      for (int col = 0; col &lt; 13; col++)
         if (board[row][col] != EMPTY)
            drawPiece(g, board[row][col], row, col);
            
}  // end paintComponent()</pre>

<break/>

<np><b><u>Playing the Game</u></b></np>

<p>The logic of the GoMoku game itself is mostly in the method "<code>void
doClickSquare(int row, int&nbsp;col)</code>", which is called by the
<code>mousePressed()</code> method when the user clicks on the square in row number
<code>row</code> and column number <code>col</code>. This method must check whether the
move is legal. If so, the move is made. The method then checks whether the move
wins the game. If so, the game ends. The game will also end if the board has
become completely full. Otherwise, play passes to the other player.</p>

<p>The current player is recorded in an instance variable named
<code>currentPlayer</code>. The value of this variable is one of the two constants
<code>WHITE</code> or <code>BLACK</code>. The game can be ended by calling a method
named <code>gameOver()</code>. I wrote a <ptype>boolean</ptype>-valued method called
<code>winner()</code> to check whether a move wins the game. (When I first wrote
this method, it did nothing but "<code>return false</code>". This let me try out
the program at this stage of development, before I started working on the
difficult problem of testing for a winner.) The <code>doClickSquare()</code> method
can be written:</p>

<pre>void doClickSquare(int row, int col) {
       // This is called by mousePressed() when a player clicks 
       // on the square in the specified row and col.  It has already 
       // been checked that a game is, in fact, in progress.
       
    /* Check that the user clicked an empty square.  If not, show an
       error message and exit. */
       
    if ( board[row][col] != EMPTY ) {
       if (currentPlayer == BLACK)
          message.setText("BLACK:  Please click an empty square.");
       else
          message.setText("WHITE:  Please click an empty square.");
       return;
    }
    
    /* Make the move.  Check if the board is full or if the move
       is a winning move.  If so, the game ends.  If not, then it's
       the other user's turn. */
       
    board[row][col] = currentPlayer;  // Make the move.
    repaint();
    
    if (winner(row,col)) {  // First, check for a winner.
       if (currentPlayer == WHITE)
          gameOver("WHITE wins the game!");
       else
          gameOver("BLACK wins the game!");
       return;
    }
    
    boolean emptySpace = false;     // Check if the board is full.
    for (int i = 0; i &lt; 13; i++)
       for (int j = 0; j &lt; 13; j++)
          if (board[i][j] == EMPTY)
             emptySpace = true;  // The board contains an empty space.
    if (emptySpace == false) {
       gameOver("The game ends in a draw.");
       return;
    }
    
    /* Continue the game.  It's the other player's turn. */
    
    if (currentPlayer == BLACK) {
       currentPlayer = WHITE;
       message.setText("WHITE:  Make your move.");
    }
    else {  
       currentPlayer = BLACK;
       message.setText("BLACK:  Make your move.");
    }
 
}  // end doClickSquare()</pre>

<break/>

<np><b><u>Determining the Winner</u></b></np>

<p>The <code>winner()</code> method is certainly the hardest part of the program.
The method must look in each of the four possible directions from the square
where the user has placed a piece. If the player has five or more pieces in a
row in that direction, then the player has won. As indicated in the exercise, a
direction can be indicated by two variables, <code>dirX</code> and <code>dirY</code>.
The values of these variables for each of the four directions are:</p>

<pre>                      dirX    dirY    Why?
                      ----    ----    --------------------------------
horizontal direction    1       0       Only x changes.
vertical direction      0       1       Only y changes.
falling diagonal        1       1       Both x and y change.
rising diagonal         1      -1       Change in opposing directions.</pre>

<p>I wrote a method "<code>int count(int player, int row, int col, int dirX, int
dirY)</code> that counts the number of pieces the specified player has in a row,
starting from the square in row number <code>row</code> and column number
<code>col</code> and looking in the direction indicated by <code>dirX</code> and
<code>dirY</code>. This method contains the code given in the exercise. It returns
the number of pieces found. My <code>winner</code> method just calls this method
for each of the four directions:</p>

<pre>/**
 * This is called just after a piece has been played on the
 * square in the specified row and column.  It determines
 * whether that was a winning move by counting the number
 * of squares in a line in each of the four possible
 * directions from (row,col).  If there are 5 squares (or more)
 * in a row in any direction, then the game is won.
 */
private boolean winner(int row, int col) {
     
   if (count( board[row][col], row, col, 1, 0 ) &gt;= 5)
      return true;
   if (count( board[row][col], row, col, 0, 1 ) &gt;= 5)
      return true;
   if (count( board[row][col], row, col, 1, -1 ) &gt;= 5)
      return true;
   if (count( board[row][col], row, col, 1, 1 ) &gt;= 5)
      return true;
      
   /* When we get to this point, we know that the game is not won. */

   return false;
   
}  // end winner()</pre>

<p>When I first wrote this method, I checked whether the number of pieces was
"<code>== 5</code>" instead of "<code>&gt;= 5</code>". This was a bug. It's possible
for a player to get more than 5 pieces in a row, if the player plays a piece in
an empty square that joins two shorter rows of pieces together.</p>

<break/>

<np><b><u>Marking the Winning Pieces</u></b></np>

<p>In my program, when a player wins, the row of pieces that wins the game is
marked with a red line. To do this, I added four instance variables of type
<ptype>int</ptype> to the <classname>Board</classname> class. The instance variables are
named <code>win_r1</code>, <code>win_c1</code>, <code>win_r2</code>, and <code>win_c2</code>.
If the game has not yet been won, then the value of <code>win_r1</code> is <code>-1</code>. The
<code>paintComponent()</code> method uses this value as a signal that it should not
draw any red line. After a player has won the game, the values of these
variables are set to mark the squares at the two ends of the winning row of
pieces. The positions of these squares are given by <code>(win_r1,win_c1)</code>
and <code>(win_r2,win_c2)</code>. If <code>win_r1</code> is greater than -1, then the
<code>paintComponent()</code> method draws a red line between these two
squares.</p>

<p>I added some code to the <code>winner()</code> and <code>count()</code> methods to
set the values of these variables properly. As the <code>count()</code> method
counts pieces in a row, it sets <code>win_r1</code>, <code>win_c1</code>,
<code>win_r2</code>, and <code>win_c2</code> to mark the location of the last piece it
finds in the two directions it checks. If the game is won, this will set the
values correctly. To handle the case where the game is not won, I added the
line "<code>win_r1&nbsp;=&nbsp;-1;</code>" to the <code>winner()</code> method, just before the
"<code>return false;</code>" statement. This ensures that the value of this
variable will be <code>-1</code> whenever the game is not yet won. (Perhaps this is all too
tricky, but I really wanted to mark the winning pieces&dots;)</p>
</exercise-discuss>
<exercise-code>
<pre>import java.awt.*;
import java.awt.event.*;
import javax.swing.*;    

/**
 * This panel lets two users play Go Moku (a.k.a Pente) against each 
 * other.  Black always starts the game.  When a player gets five-in-a-row,
 * that player wins.  The game ends in a draw if the board is filled
 * before either player wins.
 *
 * The class has a main() routine that lets it be run as a stand-alone
 * application.  The application just opens a window that uses an object
 * of type GoMoku as its content pane.
 * 
 * This panel could also be used as the content pane of an applet.  The 
 * applet size should be 350-by-250 (or very close to that).
 */

public class GoMoku extends JPanel {
   
   /**
    * Main routine makes it possible to run GoMoku as a stand-alone
    * application.  Opens a window showing a GoMoku panel; the program
    * ends when the user closes the window.
    */
   public static void main(String[] args) {
      JFrame window = new JFrame("GoMoku");
      GoMoku content = new GoMoku();
      window.setContentPane(content);
      window.pack();
      Dimension screensize = Toolkit.getDefaultToolkit().getScreenSize();
      window.setLocation( (screensize.width - window.getWidth())/2,
            (screensize.height - window.getHeight())/2 );
      window.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
      window.setResizable(false);  
      window.setVisible(true);
   }
   

   private JButton newGameButton;  // Button for starting a new game.

   private JButton resignButton;   // Button that a player can use to end the 
                                   //   game by resigning.
   
   private JLabel message;  // Label for displaying messages to the user.
   
   
   /**
    *  The constructor lays out the panel.  The work of
    *  the game is all done in the Board object.  A null layout
    *  is used, and all setup of sizes and positions is done here.
    */
   public GoMoku() {
      
      setLayout(null);  // I will do the layout myself.
      
      setPreferredSize( new Dimension(350,250) );
      
      setBackground(new Color(0,150,0));  // Dark green background.
      
      /* Create the components and add them to the applet. */
      
      Board board = new Board();  // Note: The constructor for the
                                  //   board also creates the buttons
                                  //   and label.
      add(board);
      add(newGameButton);
      add(resignButton);
      add(message);
      
      /* Set the position and size of each component by calling
         its setBounds() method. */
      
      board.setBounds(16,16,172,172); // Note:  size MUST be 172-by-172 !
      newGameButton.setBounds(210, 60, 120, 30);
      resignButton.setBounds(210, 120, 120, 30);
      message.setBounds(0, 200, 350, 30);
   }
   
   
   // ----------------------- Nested class -----------------------------------
   
   /**
    * This panel displays a 168-by-168 pixel checkerboard pattern with
    * a 2-pixel black border.  It is assumed that the size of the
    * canvas is set to exactly 172-by-172 pixels.  This class does
    * the work of letting the users play Go Moku, and it displays
    * the checkerboard.  In this program, the board has 13 rows and
    * columns of squares.
    */
   class Board extends JPanel implements ActionListener, MouseListener {
      
      int[][] board;   // The data for the board is kept here.  The values
                      //   in this array are chosen from the following constants.
      
      static final int EMPTY = 0,       // Represents an empty square.
                       WHITE = 1,       // A white piece.
                       BLACK = 2;       // A black piece.
      
      boolean gameInProgress; // Is a game currently in progress?
      
      int currentPlayer;      // Whose turn is it now?  The possible values
                              //    are WHITE and BLACK.  (This is valid only while
                              //    a game is in progress.)
      
      int win_r1, win_c1, win_r2, win_c2;  // When a player wins by getting five or more
                                           // pieces in a row, the squares at the
                                           // ends of the row are (win_r1,win_c1)
                                           // and (win_r2,win_c2).  A red line is
                                           // drawn between these squares.  When there
                                           // are not five pieces in a row, the value of
                                           // win_r1 is -1.  The values are set in the
                                           // count() method.  The value of win_r1 is
                                           // tested in the paintComponent() method.
      
      /**
       * Constructor.  Create the buttons and label.  Listen for mouse
       * clicks and for clicks on the buttons.  Create the board and
       * start the first game.
       */
      public Board() {
         setBackground(Color.LIGHT_GRAY);
         addMouseListener(this);
         resignButton = new JButton("Resign");
         resignButton.addActionListener(this);
         newGameButton = new JButton("New Game");
         newGameButton.addActionListener(this);
         message = new JLabel("",JLabel.CENTER);
         message.setFont(new  Font("Serif", Font.BOLD, 14));
         message.setForeground(Color.GREEN);
         board = new int[13][13];
         doNewGame();
      }
      

      /**
       * Respond to user's click on one of the two buttons.
       */
      public void actionPerformed(ActionEvent evt) {
         Object src = evt.getSource();
         if (src == newGameButton)
            doNewGame();
         else if (src == resignButton)
            doResign();
      }
      
      
      /**
       * Begin a new game; this is called by the actionPerformed()
       * method when a user clicks the New Game button.
       */
      void doNewGame() {
         if (gameInProgress == true) {
               // This should not be possible because New Game button
               // is enabled only when it is legal to use it, but it doesn't 
               // hurt to check.
            message.setText("Finish the current game first!");
            return;
         }
         for (int row = 0; row &lt; 13; row++)       // Fill the board with EMPTYs
            for (int col = 0; col &lt; 13; col++)
               board[row][col] = EMPTY;
         currentPlayer = BLACK;   // BLACK moves first.
         message.setText("BLACK:  Make your move.");
         gameInProgress = true;
         newGameButton.setEnabled(false);
         resignButton.setEnabled(true);
         win_r1 = -1;  // This value indicates that no red line is to be drawn.
         repaint();
      }
      
      
      /**
       * Current player resigns; this is called by the actionPerformed()
       * method when a user clicks the Resign button.  Game ends, and
       * opponent wins.
       */
      void doResign() {
         if (gameInProgress == false) {
                // This should not be possible.
            message.setText("There is no game in progress!");
            return;
         }
         if (currentPlayer == WHITE)
            message.setText("WHITE resigns.  BLACK wins.");
         else
            message.setText("BLACK resigns.  WHITE wins.");
         newGameButton.setEnabled(true);
         resignButton.setEnabled(false);
         gameInProgress = false;
      }
      
      
      /**
       * This method is called whenever the game ends.  The parameter, str,
       * is displayed as a message, and the buttons are enabled/disabled
       * to reflect the fact that a game is not currently in progress.
       */
      void gameOver(String str) {
         message.setText(str);
         newGameButton.setEnabled(true);
         resignButton.setEnabled(false);
         gameInProgress = false;
      }
      
      
      /**
       * This is called by mousePressed() when a player clicks on the
       * square in the specified row and col.  It has already been checked
       * that a game is, in fact, in progress.
       */
      void doClickSquare(int row, int col) {
         
         /* Check that the user clicked an empty square.  If not, show an
          error message and exit. */
         
         if ( board[row][col] != EMPTY ) {
            if (currentPlayer == BLACK)
               message.setText("BLACK:  Please click an empty square.");
            else
               message.setText("WHITE:  Please click an empty square.");
            return;
         }
         
         /* Make the move.  Check if the board is full or if the move
          is a winning move.  If so, the game ends.  If not, then it's
          the other user's turn. */
         
         board[row][col] = currentPlayer;  // Make the move.
         repaint();
         
         if (winner(row,col)) {  // First, check for a winner.
            if (currentPlayer == WHITE)
               gameOver("WHITE wins the game!");
            else
               gameOver("BLACK wins the game!");
            return;
         }
         
         boolean emptySpace = false;     // Check if the board is full.
         for (int i = 0; i &lt; 13; i++)
            for (int j = 0; j &lt; 13; j++)
               if (board[i][j] == EMPTY)
                  emptySpace = true;
         if (emptySpace == false) {
            gameOver("The game ends in a draw.");
            return;
         }
         
         /* Continue the game.  It's the other player's turn. */
         
         if (currentPlayer == BLACK) {
            currentPlayer = WHITE;
            message.setText("WHITE:  Make your move.");
         }
         else {  
            currentPlayer = BLACK;
            message.setText("BLACK:  Make your move.");
         }
         
      }  // end doClickSquare()
      
      
      /**
       * This is called just after a piece has been played on the
       * square in the specified row and column.  It determines
       * whether that was a winning move by counting the number
       * of squares in a line in each of the four possible
       * directions from (row,col).  If there are 5 squares (or more)
       * in a row in any direction, then the game is won.
       */
      private boolean winner(int row, int col) {
         
         if (count( board[row][col], row, col, 1, 0 ) &gt;= 5)
            return true;
         if (count( board[row][col], row, col, 0, 1 ) &gt;= 5)
            return true;
         if (count( board[row][col], row, col, 1, -1 ) &gt;= 5)
            return true;
         if (count( board[row][col], row, col, 1, 1 ) &gt;= 5)
            return true;
         
         /* When we get to this point, we know that the game is not
          won.  The value of win_r1, which was changed in the count()
          method, has to be reset to -1, to avoid drawing a red line
          on the board. */
         
         win_r1 = -1;
         return false;
         
      }  // end winner()
      
      
      /**
       * Counts the number of the specified player's pieces starting at
       * square (row,col) and extending along the direction specified by
       * (dirX,dirY).  It is assumed that the player has a piece at
       * (row,col).  This method looks at the squares (row + dirX, col + dirY),
       * (row + 2*dirX, col + 2*dirY), ... until it hits a square that is
       * off the board or is not occupied by one of the player's pieces.
       * It counts the squares that are occupied by the player's pieces.
       * Furthermore, it sets (win_r1,win_c1) to mark last position where
       * it saw one of the player's pieces.  Then, it looks in the
       * opposite direction, at squares (row - dirX, col-dirY),
       * (row - 2*dirX, col - 2*dirY), ... and does the same thing.
       * Except, this time it sets (win_r2,win_c2) to mark the last piece.
       * Note:  The values of dirX and dirY must be 0, 1, or -1.  At least
       * one of them must be non-zero.
       */
      private int count(int player, int row, int col, int dirX, int dirY) {
         
         int ct = 1;  // Number of pieces in a row belonging to the player.
         
         int r, c;    // A row and column to be examined
         
         r = row + dirX;  // Look at square in specified direction.
         c = col + dirY;
         while ( r &gt;= 0 &amp;&amp; r &lt; 13 &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; 13 &amp;&amp; board[r][c] == player ) {
            // Square is on the board and contains one of the players's pieces.
            ct++;
            r += dirX;  // Go on to next square in this direction.
            c += dirY;
         }
         
         win_r1 = r - dirX;  // The next-to-last square looked at.
         win_c1 = c - dirY;  //    (The LAST one looked at was off the board or
         //    did not contain one of the player's pieces.
         
         r = row - dirX;  // Look in the opposite direction.
         c = col - dirY;
         while ( r &gt;= 0 &amp;&amp; r &lt; 13 &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; 13 &amp;&amp; board[r][c] == player ) {
            // Square is on the board and contains one of the players's pieces.
            ct++;
            r -= dirX;   // Go on to next square in this direction.
            c -= dirY;
         }
         
         win_r2 = r + dirX;
         win_c2 = c + dirY;
         
         // At this point, (win_r1,win_c1) and (win_r2,win_c2) mark the endpoints
         // of the line of pieces belonging to the player.
         
         return ct;
         
      }  // end count()
      
      
      /**
       * Draws the board and the pieces on the board.  If the game has
       * been won by getting five or more pieces in a row, draws a red line
       * through the pieces.
       */
      public void paintComponent(Graphics g) {
         
         super.paintComponent(g); // Fill with background color, lightGray
         
         /* Draw a two-pixel black border around the edges of the canvas,
          and draw grid lines in darkGray.  */
         
         g.setColor(Color.DARK_GRAY);
         for (int i = 1; i &lt; 13; i++) {
            g.drawLine(1 + 13*i, 0, 1 + 13*i, getSize().height);
            g.drawLine(0, 1 + 13*i, getSize().width, 1 + 13*i);
         }
         g.setColor(Color.BLACK);
         g.drawRect(0,0,getSize().width-1,getSize().height-1);
         g.drawRect(1,1,getSize().width-3,getSize().height-3);
         
         /* Draw the pieces that are on the board. */
         
         for (int row = 0; row &lt; 13; row++)
            for (int col = 0; col &lt; 13; col++)
               if (board[row][col] != EMPTY)
                  drawPiece(g, board[row][col], row, col);
         
         /* If the game has been won, then win_r1 &gt;= 0.  Draw a line to mark
          the five (or more) winning pieces. */
         
         if (win_r1 &gt;= 0)
            drawWinLine(g);
         
      }  // end paintComponent()
      
      
      /**
       * Draw a piece in the square at (row,col).  The color is specified
       * by the piece parameter, which should be either BLACK or WHITE.
       */
      private void drawPiece(Graphics g, int piece, int row, int col) {
         if (piece == WHITE)
            g.setColor(Color.WHITE);
         else
            g.setColor(Color.BLACK);
         g.fillOval(3 + 13*col, 3 + 13*row, 10, 10);
      }
      
      
      /**
       * Draw a 2-pixel wide red line from the middle of the square at
       * (win_r1,win_c1) to the middle of the square at (win_r2,win_c2).
       * This routine is called to mark the pieces that won the game.
       * The values of the variables are set in the count() method.
       */
      private void drawWinLine(Graphics g) {
         g.setColor(Color.RED);
         g.drawLine( 8 + 13*win_c1, 8 + 13*win_r1, 8 + 13*win_c2, 8 + 13*win_r2 );
         if (win_r1 == win_r2)
            g.drawLine( 8 + 13*win_c1, 7 + 13*win_r1, 8 + 13*win_c2, 7 + 13*win_r2 );
         else
            g.drawLine( 7 + 13*win_c1, 8 + 13*win_r1, 7 + 13*win_c2, 8 + 13*win_r2 );
      }
      
      
      /**
       * Respond to a user click on the board.  If no game is
       * in progress, show an error message.  Otherwise, find
       * the row and column that the user clicked and call
       * doClickSquare() to handle it.
       */
      public void mousePressed(MouseEvent evt) {
         if (gameInProgress == false)
            message.setText("Click \"New Game\" to start a new game.");
         else {
            int col = (evt.getX() - 2) / 13;
            int row = (evt.getY() - 2) / 13;
            if (col &gt;= 0 &amp;&amp; col &lt; 13 &amp;&amp; row &gt;= 0 &amp;&amp; row &lt; 13)
               doClickSquare(row,col);
         }
      }
      
      
      public void mouseReleased(MouseEvent evt) { }
      public void mouseClicked(MouseEvent evt) { }
      public void mouseEntered(MouseEvent evt) { }
      public void mouseExited(MouseEvent evt) { }
      
      
   }  // end nested class Board
   
   
   
} // end class GoMoku

</pre>
</exercise-code>
</exercise>
   
   

</exercises>